#### 函数声明

用关键字**fun**声明函数

#### 用法

成员之间可直接调用，使用对象调用时用点操作符

```
class B707 {

    var name = run()

    fun run(age: Int = 1) {

    }

    class b707 {
        var v = B707().run()
    }
}
```

##### 参数

使用Pascal表示法：name **: **type，

* 参数之间用逗号分隔
* 必须显式声明类型
* 可设置默认值

覆盖方法时若参数有默认值，则覆盖方法不能设置默认值，用原方法的默认值

##### 命名参数

调用函数时使用命名的函数参数

```
class C707 {

    fun eat(age: Int = 1, name: String, sex: Boolean) {}

}

-----------测试----------------
        C707().eat(sex = false, name = "CC")
        C707().eat(12, "CC", false)
        C707().eat(12, name = "CC", sex = false)

```

命名参数之间使用时可以换位置，但所有的位置参数必须放在第一个命名参数之前

> java中不能使用命名参数是由于java字节码不一定保留参数名称

#### 函数的返回

默认无返回就是返回Unit

```
    fun read() {}
    // 等价于
    fun read(): Unit {}
```

有具体返回类型时需显式声明返回类型

```
    fun write(): Int {
        return 1
    }
```

#### 可变参数（vararg）

通常用于函数最后一个参数，可动态传入参数数量，只能有一个参数能设置为可变的

```
fun speak(age: Int=1,vararg v:String){
}

-------------测试----------------------

C707().speak(2,"CC", "HH", "EE")
C707().speak(v = *arrayOf("CC", "HH", "EE"))
```

可变参数（vararg）的命名参数需要用伸展操作符（**\***）修饰



> 参数是函数类型且是最后一个参数，则可表示为lambda表达式，调用时从函数后花括号内返回参数值，
>
> ```
>    fun read1(age: Int=1, sex: () -> Boolean): Unit {}
>    
>    ----------测试-----------------
>    
>            C707().read1(2) {
>             var re = 4
>             // 参数sex的值
>             true 
>         }
> ```

#### 中缀表示法

忽略调用的点（.）与圆括号（\(\)），用关键字**infix**修饰的函数可使用

* 必须是成员或者扩展函数
* 只能有一个参数
* 参数不能是可变（vararg），不能有默认值

```

    infix fun run(s: Int) {
        println("$this---s=$s")
    }
    
    ------------测试---------------------
    
        C707() run 45
     // C707().run(45)
     
     //输出
     com.example.kotlin.d707.C707@1ee0005---s=45
```

> 优先级低于算术操作符、类型转换和rangeTo操作符；高于布尔和位运算操作符等

当在成员函数内使用需用**this**显式声明接受者

```
    fun go() {
        this run 20
    //  run(20)
    }
```

#### 作用域

* 顶层函数，函数可在文件顶层声明
* 局部函数，函数内还可以声明函数
* 成员函数，在类或对象类声明
* 扩展函数

局部函数可使用外部函数变量

```
    fun A() {
        var a=1
        fun B() {
            var a=a
        }
    }
```



